/*
  ____            _       _
 / ___|  ___ _ __(_) __ _| |   __ _  ___ __ _
 \___ \ / _ \ '__| |/ _` | |  / _` |/ __/ _` |
  ___) |  __/ |  | | (_| | | | (_| | (_| (_| |_
 |____/ \___|_|  |_|\__,_|_|  \__,_|\___\__, (_)
                                           |_|
Serial port acquisitor
NOTE: This example expects data generated by the arduino sketchs available on
https://github.com/Smart-ICA/Maryem/edit/main/Arduino
This is an extended version of the original "serial_acq.hpp" 
developed by P.Paolo Bosetti.

 Generalized version:
      - reads JSON lines (NDJSON) from 1..N serial ports (ports[] or port)
      - maps JSON paths ("path": "a.b.c") to a vector of N channels (N = settings["channels"])
      - manages stable timestamps using 'ts_key' (e.g., "millis") to reconstruct system_clock::time_point
      - keeps compatibility with the legacy schema (j["data"]["AI1..3"]) if no 'map' is provided
      - also tolerates the INI variant “without JSON objects”: map_paths/map_to/map_ports

NOTE: The Arduino must send ONE JSON line per sample (terminated by '\n').
*/

#pragma once

#include <serial/serial.h>
#include "acquisitor.hpp"
#include <nlohmann/json.hpp>
#include <vector>
#include <optional>
#include <chrono>
#include <cmath>
#include <limits>     // for std::numeric_limits
#include <sstream>
#include <algorithm>

using nlohmann::json;
using namespace std;
using namespace std::chrono;

// Specialization of Acquisitor for a VECTOR of doubles (variable size)
// instead of std::array<double,3>. This allows 4, 7, 8 channels, etc.
class SerialportAcquisitor : public Acquisitor<vector<double>> {
public:
  // Same constructor, setup() is called
  SerialportAcquisitor(json j, size_t capa = 0) : Acquisitor(j, capa) { setup(); }

  ~SerialportAcquisitor() {
    // Proper closure when multiple ports are open
    for (auto &sp : _serials) {
      if (sp && sp->isOpen()) sp->close();
    }
  }

  // Prepares the serial connection and reads INI parameters
  void setup() override {
    // Supports 'ports' (list) OR the legacy 'port' (single). Timeout and baud are configurable.
    if (!_serials.empty()) {
      bool all_open = true;
      for (auto &s : _serials) all_open &= (s && s->isOpen());
      if (all_open) return;
    }

    // Number of output channels (e.g., 4 for accel+mic, 3 for currents+powers+mic)
    _channels = _settings.value("channels", 3);
    if (_channels <= 0) _channels = 3; // safety check

    _ports.clear();
    if (_settings.contains("ports")) {
      _ports = _settings["ports"].get<vector<string>>();
    } else if (_settings.contains("port")) {
      _ports.push_back(_settings.value("port", ""));
    }
    _baud = _settings.value("baud", 115200);
    _timeout = serial::Timeout::simpleTimeout(_settings.value("timeout", 100));

    _ts_key = _settings.value("ts_key", string(""));

    //  map: accept either a JSON array or a JSON string 
    _map = nlohmann::json::array();
    if (_settings.contains("map")) {
      try {
        if (_settings["map"].is_string()) {
          _map = nlohmann::json::parse(_settings["map"].get<std::string>());
        } else if (_settings["map"].is_array()) {
          _map = _settings["map"];
        }
      } catch (const std::exception &e) {
        std::cerr << "[SerialportAcquisitor] map parse error: " << e.what() << "\n";
        _map = nlohmann::json::array();
      }
    }

    //  Alternative without JSON objects: map_paths/map_to/map_ports (more robust INI) 
    if (_map.empty() && _settings.contains("map_paths") && _settings.contains("map_to")) {
      auto paths = _settings["map_paths"].get<std::vector<std::string>>();
      auto tos   = _settings["map_to"].get<std::vector<int>>();
      std::vector<int> ports(paths.size(), 0);
      if (_settings.contains("map_ports")) {
        ports = _settings["map_ports"].get<std::vector<int>>();
      }
      if (paths.size() == tos.size() && ports.size() == paths.size()) {
        for (size_t i = 0; i < paths.size(); ++i) {
          _map.push_back({{"port", ports[i]}, {"path", paths[i]}, {"to", tos[i]}});
        }
      } else {
        std::cerr << "[SerialportAcquisitor] map_paths/map_to/map_ports length mismatch\n";
      }
    }

    // IMPORTANT: only after attempting to build _map!
    _legacy_expect_data_ai = _map.empty();

    _serials.clear();
    _base_clock.assign(_ports.size(), std::nullopt);

    for (auto const &p : _ports) {
      auto s = make_unique<serial::Serial>(p, _baud, _timeout);
      if (!s->isOpen()) s->open();
      _serials.push_back(std::move(s));
    }

    // Small startup log for debugging
    std::cerr << "[SerialportAcquisitor] mode=" << (_legacy_expect_data_ai ? "legacy(data.AI*)" : "mapping")
              << " channels=" << _channels
              << " map_size=" << _map.size()
              << " ports=" << _ports.size() << "\n";
  }


  // Acquire one sample: reads at most one JSON line from any serial port
  void acquire() override {
    if (is_full()) throw AcquisitorException();

    for (size_t i = 0; i < _serials.size(); ++i) {
      auto &ser = _serials[i];
      if (!ser || !ser->isOpen()) continue;

      // readline() with timeout (defined in _timeout). May return empty.
      string raw = ser->readline();
      if (raw.empty()) continue;

      // some libraries add extra bytes: isolate strictly { ... }
      string line;
      if (!sanitize_json_line(raw, line)) continue;

      json j;
      try {
        j = json::parse(line);
      } catch (exception &e) {
        cerr << "[SerialportAcquisitor] Cannot parse JSON on port "
             << (_ports.size()>i ? _ports[i] : string("?"))
             << ": " << e.what() << "\n";
        continue;
      }

      //Prepare a generic sample: time + vector<double> of size _channels
      Acquisitor::sample s;
      s.data.assign(_channels, std::numeric_limits<double>::quiet_NaN());  // initialize all channels with NaN

      //Timestamp: if 'ts_key' is present (e.g., "millis"), reconstruct a stable time_point
      if (!_ts_key.empty() && j.contains(_ts_key)) {
        try {
          long long ms = j[_ts_key].get<long long>();
          auto now_tp = system_clock::now();
          if (!_base_clock[i].has_value()) {
            // first measurement on this port: base = now - millis
            _base_clock[i] = now_tp - milliseconds(ms);
          }
          s.time = *_base_clock[i] + milliseconds(ms);
        } catch (...) {
          s.time = system_clock::now();
        }
      } else {
        s.time = system_clock::now();
      }

      // Fill data channels
      if (_legacy_expect_data_ai) {
        //  LEGACY MODE (demo) — SAFE 
        const json* d = (j.contains("data") && j["data"].is_object()) ? &j["data"] : nullptr;
        if (!d) {
          // no 'data' → not legacy → skip this line safely
          continue;
        }
        if (_channels >= 1) s.data[0] = d->value("AI1", std::numeric_limits<double>::quiet_NaN());
        if (_channels >= 2) s.data[1] = d->value("AI2", std::numeric_limits<double>::quiet_NaN());
        if (_channels >= 3) s.data[2] = d->value("AI3", std::numeric_limits<double>::quiet_NaN());
      } else {
        //  MAPPING MODE
        // Each entry: {"port":int, "path":"acceleration.x_g", "to":int}
        for (auto const &m : _map) {
          try {
            int   p    = m.value("port", 0);
            int   to   = m.value("to",   0);
            auto  path = m.at("path").get<string>();
            if ((int)i != p) continue;           // wrong port
            if (to < 0 || to >= _channels) continue;
            double val;
            if (json_get_by_path(j, path, val)) {
              s.data[(size_t)to] = val;
            }
          } catch (...) { /* ignore invalid map entries */ }
        }
      }

      // Push one sample and let fill_buffer() call acquire() again
      _data.push_back(std::move(s));
      return;
    }

    // if no port returned a line this cycle → nothing pushed (fill_buffer() will retry)
  }

private:
  // Cleanly extracts only the substring "{...}" from a line
  static bool sanitize_json_line(const string &in, string &out) {
    auto b = in.find('{');
    if (b == string::npos) return false;
    auto e = in.rfind('}');
    if (e == string::npos || e < b) return false;
    out = in.substr(b, e - b + 1);
    while (!out.empty() && (out.back()=='\r' || out.back()=='\n')) out.pop_back();
    return !out.empty();
  }

  // Access a path "a.b.c" without relying on at_path (for version compatibility)
  static bool json_get_by_path(json const &j, string const &path, double &out) {
    try {
      json const* cur = &j;
      size_t start = 0;
      while (true) {
        size_t pos = path.find('.', start);
        string key = path.substr(start, pos == string::npos ? string::npos : (pos - start));
        if (!cur->contains(key)) return false;
        cur = &(*cur)[key];
        if (pos == string::npos) break;
        start = pos + 1;
      }
      if (cur->is_number_float() || cur->is_number_integer() || cur->is_number_unsigned()) {
        out = cur->get<double>();
        return true;
      }
      return false;
    } catch (...) { return false; }
  }

private:
  int _channels{3};                                    // number of output channels
  vector<string> _ports;
  size_t _baud{};
  serial::Timeout _timeout;
  vector<unique_ptr<serial::Serial>> _serials;

  string _ts_key;                                      // e.g., "millis"
  json   _map;                                         // mapping JSON→channels
  bool   _legacy_expect_data_ai{false};

  vector<optional<system_clock::time_point>> _base_clock; // time base per port
};
