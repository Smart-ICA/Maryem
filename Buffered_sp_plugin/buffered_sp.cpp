/*
  ____                                   _             _       
 / ___|  ___  _   _ _ __ ___ ___   _ __ | |_   _  __ _(_)_ __  
 \___ \ / _ \| | | | '__/ __/ _ \ | '_ \| | | | |/ _` | | '_ \ 
  ___) | (_) | |_| | | | (_|  __/ | |_) | | |_| | (_| | | | | |
 |____/ \___/ \__,_|_|  \___\___| | .__/|_|\__,_|\__, |_|_| |_|
                                  |_|            |___/         
# A Template for BufferedPlugin, a Source Plugin
# Generated by the command: plugin -t source -d buffered_plugin buffered
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2025-10-07T09:21:48.630+0200
# NOTICE: MADS Version 1.4.0
*/

// Mandatory included headers
#include <source.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

// other includes as needed here
#include <chrono>
#include <sstream>              // [MOD] petit utilitaire pour convertir json -> string
#include "serial_acq.hpp"       // [MOD] La classe gère désormais JSON NDJSON multi-ports + mapping

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "buffered_sp"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

// [MOD] helper sûr pour convertir une valeur json en string (évite std::to_string(json))
static inline std::string json_to_string(const json &j) {
  if (j.is_number_integer())   return std::to_string(j.get<long long>());
  if (j.is_number_unsigned())  return std::to_string(j.get<unsigned long long>());
  if (j.is_number_float())     return std::to_string(j.get<double>());
  if (j.is_string())           return j.get<std::string>();
  return j.dump();
}

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class BufferedPlugin : public Source<json> {
public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type get_output(json &out,
                         std::vector<unsigned char> *blob = nullptr) override {
    out.clear();
    if (!_agent_id.empty()) out["agent_id"] = _agent_id;

    // [MOD] Remplit le tampon depuis le/les ports série (JSON NDJSON + mapping)
    _acq->fill_buffer();

    // [MOD] Mise en forme de la sortie :
    // out["data"] = [[t_rel, ch0, ch1, ... chN], ...]  // N = channels
    out["data"] = json::array();
    json e = json::array();
    for (auto &sample : _acq->data()) {
      e = json::array();
      e.push_back(sample.time_since(_today));
      // [MOD] on pousse tous les canaux trouvés (taille dynamique)
      for (double v : sample.data) e.push_back(v);
      out["data"].push_back(e);
    }

    return return_type::success;
  }

  void set_params(void const *params) override {
    Source::set_params(params);
    // [MOD] valeurs par défaut
    _params["capacity"]  = 100;
    _params["mean"]      = 10;    // (hérité du template — pas utilisé ici)
    _params["sd"]        = 2;     // (hérité du template — pas utilisé ici)
    _params["tz_offset"] = 2;
    _params["channels"]  = 3;     // [MOD] défaut

    // [MOD] On merge les paramètres fournis (ports, baud, timeout, ts_key, channels, map…)
    _params.merge_patch(*(json *)params);

    // Base temporelle (début de journée - tz_offset)
    _today = floor<chrono::days>(chrono::system_clock::now()) - std::chrono::hours(_params["tz_offset"]);

    // [MOD] SerialportAcquisitor supporte :
    //       - 'ports' (liste) OU 'port' unique
    //       - 'baud', 'timeout'
    //       - 'ts_key' (ex. "millis")
    //       - 'channels' (dimension du vecteur de sortie)
    //       - 'map' OU map_paths/map_to/map_ports
    _acq = make_unique<SerialportAcquisitor>(_params);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override {
    // [MOD] Quelques infos utiles à l’écran
    string ports = _params.contains("ports") ? _params["ports"].dump() 
                  : (_params.contains("port") ? _params["port"].get<string>() : string("[]"));
    return {
      {"Capacity",   json_to_string(_params["capacity"])},
      {"Channels",   json_to_string(_params["channels"])},
      {"Ports",      ports},
      {"TS key",     _params.value("ts_key", string(""))},
      {"TZ offset",  json_to_string(_params["tz_offset"])}
    };
  };

private:
  // Define the fields that are used to store internal resources
  unique_ptr<SerialportAcquisitor> _acq;
  chrono::time_point<chrono::system_clock, chrono::nanoseconds> _today;
};

/* ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SOURCE_DRIVER(BufferedPlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

[MOD] Main de test facultatif (utile hors MADS pour un smoke-test rapide).
     Tu peux le laisser, mais MADS n’en a pas besoin pour charger le .plugin.
*/
#ifdef BUILD_STANDALONE
int main(int argc, char const *argv[]) {
  BufferedPlugin plugin;
  json output, params;

  // Exemple minimal pour un accéléromètre + micro (4 canaux)
  params["capacity"] = 100;
  params["ports"]    = json::array({"/dev/ttyACM0"});
  params["baud"]     = 1000000;
  params["timeout"]  = 50;
  params["tz_offset"]= 2;
  params["ts_key"]   = "millis";
  params["channels"] = 4;
  params["map"] = json::array({
    { {"port",0}, {"path","acceleration.x_g"},     {"to",0} },
    { {"port",0}, {"path","acceleration.y_g"},     {"to",1} },
	{ {"port",0}, {"path","acceleration.z_g"},     {"to",2} },
    { {"port",0}, {"path","sound_level"},          {"to",3} }
  });

  plugin.set_params(&params);
  plugin.get_output(output);
  cout << "Output: " << output.dump(2) << endl;
  return 0;
}
#endif

